import{List as t,Logger as e,ObjectFunction as s,Map as r}from"./coreutil_v1.js";import{ContainerDatabaseStorage as i}from"./containerbridge_v1.js";class n{constructor(t,e,s){this.name=t,this.path=e,this.unique=s}}class o{constructor(){this.storeName=null,this.keyPath=null,this.indexList=new t}withStoreName(t){return this.storeName=t,this}withKeyPath(t){return this.keyPath=t,this}withIndex(t,e,s){return this.indexList.add(new n(t,e,s)),this}}class a{constructor(){this.version=1,this.storeConfigList=new t}withVersion(t){return this.version=t,this}withStoreConfig(t){return this.storeConfigList.add(t),this}}const c=new e("StoreConfig");class u{constructor(t){this.dbConfig=t}updgrade(t){c.info("Upgrade needed");const e=t.target.result;this.dbConfig.storeConfigList.forEach((t=>{e.objectStoreNames.contains(t.storeName)&&e.deleteObjectStore(t.storeName);const s=e.createObjectStore(t.storeName,{keyPath:t.keyPath});return t.indexList.forEach((t=>{s.createIndex(t.name,t.path,{unique:t.unique});return!0})),!0}))}}class h{constructor(){this.putSubscribers=new t,this.deleteSubscribers=new t}subscribePut(t){t instanceof s&&this.putSubscribers.add(new WeakRef(t))}subscribeDelete(t){t instanceof s&&this.deleteSubscribers.add(new WeakRef(t))}notifyPut(e){let s=[];this.putSubscribers.forEach(((t,r)=>{let i=t.deref();return i?i.call(e):s.push(t),!0}),this),new t(s).forEach(((t,e)=>{this.putSubscribers.remove(t)}))}notifyDelete(e){let s=[];this.deleteSubscribers.forEach(((t,r)=>{let i=t.deref();return i?i.call(e):s.push(t),!0}),this),new t(s).forEach(((t,e)=>{this.deleteSubscribers.remove(t)}))}}class b{constructor(t){this.db=t,this.subscriptionManagerMap=new r}static fromStore(t,e){const s=new u(e);return new Promise(((r,n)=>{const o=i.open(t,e.version);o.onerror=t=>{LOG.error(t),n(t)},o.onsuccess=()=>{r(new b(o.result))},o.onupgradeneeded=s.updgrade.bind(s)}))}static mapEntity(t,e){return e?Object.assign(new t,e):null}transaction(t,e){return this.db.transaction(e,t)}objectStore(t,e){return t.objectStore(e)}index(t,e){return t.index(e)}putEntity(t,e){const s=this.transaction("readwrite",e).objectStore(e).put(t),r=this;return new Promise(((i,n)=>{s.onsuccess=()=>{r.notifyPut(t,e),i(t)},s.onerror=t=>{n(t)}}))}getEntity(t,e,s){const r=this.transaction("readonly",s).objectStore(s).get(t);return new Promise(((t,s)=>{r.onsuccess=()=>{t(b.mapEntity(e,r.result))},r.onerror=t=>{s(t)}}))}deleteEntity(t,e){const s=this.transaction("readwrite",e).objectStore(e).delete(t),r=this;return new Promise(((i,n)=>{s.onsuccess=()=>{r.notifyDelete(t,e),i(s.result)},s.onerror=t=>{n(t)}}))}notifyDelete(t,e){this.subscriptionManagerMap.contains(e)&&this.subscriptionManagerMap.get(e).notifyDelete(t)}notifyPut(t,e){this.subscriptionManagerMap.contains(e)&&this.subscriptionManagerMap.get(e).notifyPut(t)}subscribePut(t,e){this.subscriptionManagerMap.contains(t)||this.subscriptionManagerMap.set(t,new h),this.subscriptionManagerMap.get(t).subscribePut(e)}subscribeDelete(t,e){this.subscriptionManagerMap.contains(t)||this.subscriptionManagerMap.set(t,new h),this.subscriptionManagerMap.get(t).subscribeDelete(e)}}export{u as DBConfigurer,b as DBManager,a as DbConfig,n as IndexConfig,o as StoreConfig,h as SubscriptionManager};
