import{Logger as t,List as e,ObjectFunction as s,Map as r}from"./coreutil_v1.js";import{ContainerDatabaseStorage as i}from"./containerbridge_v1.js";const n=new t("StoreConfig");class o{constructor(t){this.storeConfig=t}updgrade(t){n.info("Upgrade needed");const e=t.target.result;e.objectStoreNames.contains(this.storeConfig.storeName)&&e.deleteObjectStore(this.storeConfig.storeName);e.createObjectStore(this.storeConfig.storeName,{keyPath:this.storeConfig.keyPath}).createIndex(this.storeConfig.indexName,this.storeConfig.indexPath,{unique:this.storeConfig.indexUnique})}}class a{constructor(t,e,s){this.name=t,this.path=e,this.unique=s}}class c{constructor(){this.version=1,this.storeName=null,this.keyPath=null,this.indexList=new e}withVersion(t){return this.version=t,this}withStoreName(t){return this.storeName=t,this}withKeyPath(t){return this.keyPath=t,this}withIndex(t,e,s){return this.indexList.add(new a(t,e,s)),this}}class u{constructor(){this.putSubscribers=new e,this.deleteSubscribers=new e}subscribe(t,e){t instanceof s&&this.putSubscribers.add(new WeakRef(t)),e instanceof s&&this.deleteSubscribers.add(new WeakRef(e))}notifyPut(t){let s=[];this.putSubscribers.forEach(((e,r)=>{let i=e.deref();return i?i.call(t):s.push(e),!0}),this),new e(s).forEach(((t,e)=>{this.putSubscribers.remove(t)}))}notifyDelete(t){let s=[];this.deleteSubscribers.forEach(((e,r)=>{let i=e.deref();return i?i.call(t):s.push(e),!0}),this),new e(s).forEach(((t,e)=>{this.deleteSubscribers.remove(t)}))}}class h{constructor(t){this.db=t,this.subscriptionManagerMap=new r}static fromStore(t,e){const s=new o(e);return new Promise(((e,r)=>{const n=i.open(t,1);n.onerror=t=>{LOG.error(t),r(t)},n.onsuccess=()=>{e(new h(n.result))},n.onupgradeneeded=s.updgrade.bind(s)}))}static mapEntity(t,e){return e?Object.assign(new t,e):null}transaction(t,e){return this.db.transaction(e,t)}objectStore(t,e){return t.objectStore(e)}index(t,e){return t.index(e)}putEntity(t,e){const s=this.transaction("readwrite",e).objectStore(e).put(t),r=this;return new Promise(((i,n)=>{s.onsuccess=()=>{r.notifyPut(t,e),i(t)},s.onerror=t=>{n(t)}}))}getEntity(t,e,s){const r=this.transaction("readonly",s).objectStore(s).get(t);return new Promise(((t,s)=>{r.onsuccess=()=>{t(h.mapEntity(e,r.result))},r.onerror=t=>{s(t)}}))}deleteEntity(t,e){const s=this.transaction("readwrite",e).objectStore(e).delete(t),r=this;return new Promise(((i,n)=>{s.onsuccess=()=>{r.notifyDelete(t,e),i(s.result)},s.onerror=t=>{n(t)}}))}notifyDelete(t,e){this.subscriptionManagerMap.contains(e)&&this.subscriptionManagerMap.get(e).notifyDelete(t)}notifyPut(t,e){this.subscriptionManagerMap.contains(e)&&this.subscriptionManagerMap.get(e).notifyPut(t)}subscribePut(t,e){this.subscriptionManagerMap.contains(t)||this.subscriptionManagerMap.set(t,new u),this.subscriptionManagerMap.get(t).subscribe(e)}subscribe(t,e,s){this.subscriptionManagerMap.contains(s)||this.subscriptionManagerMap.set(s,new u),this.subscriptionManagerMap.get(s).subscribe(t,e)}}export{o as DBConfigurer,h as DBManager,a as IndexConfig,c as StoreConfig,u as SubscriptionManager};
