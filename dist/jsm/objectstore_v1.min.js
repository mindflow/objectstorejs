import{Logger,List,ObjectFunction,Map}from"./coreutil_v1.js";const LOG$1=new Logger("StoreConfig");class DBConfigurer{constructor(n){this.storeConfig=n}updgrade(n){LOG$1.info("Upgrade needed");const t=n.target.result;t.objectStoreNames.contains(this.storeConfig.storeName)&&t.deleteObjectStore(this.storeConfig.storeName);t.createObjectStore(this.storeConfig.storeName,{keyPath:this.storeConfig.keyPath}).createIndex(this.storeConfig.indexName,this.storeConfig.indexPath,{unique:this.storeConfig.indexUnique})}}class IndexConfig{constructor(n,t,e){this.name=n,this.path=t,this.unique=e}}class StoreConfig{constructor(){this.version=1,this.storeName=null,this.keyPath=null,this.indexList=new List}withVersion(n){return this.version=n,this}withStoreName(n){return this.storeName=n,this}withKeyPath(n){return this.keyPath=n,this}withIndex(n,t,e){return this.indexList.add(new IndexConfig(n,t,e)),!0}}class SubscriptionManager{constructor(){this.putSubscribers=new List,this.deleteSubscribers=new List}subscribe(n,t){n instanceof ObjectFunction&&this.putSubscribers.add(new WeakRef(n)),t instanceof ObjectFunction&&this.deleteSubscribers.add(new WeakRef(t))}notifyPut(n){let t=[];this.putSubscribers.forEach((e,i)=>{let s=e.deref();s?s.call(n):t.push(e);return!0},this),new List(t).forEach((n,t)=>{this.putSubscribers.remove(n)})}notifyDelete(n){let t=[];this.deleteSubscribers.forEach((e,i)=>{let s=e.deref();s?s.call(n):t.push(e);return!0},this),new List(t).forEach((n,t)=>{this.deleteSubscribers.remove(n)})}}class DBManager{constructor(n){this.db=n,this.subscriptionManagerMap=new Map}static fromStore(n,t){const e=new DBConfigurer(t);return new Promise((t,i)=>{const s=window.indexedDB.open(n,1);s.onerror=(n=>{LOG.error(n);i(n)});s.onsuccess=(()=>{t(new DBManager(s.result))});s.onupgradeneeded=e.updgrade})}static mapEntity(n,t){return t?Object.assign(new n,t):null}transaction(n,t){return this.db.transaction(t,n)}objectStore(n,t){return n.objectStore(t)}index(n,t){return n.index(t)}putEntity(n,t){const e=this.transaction("readwrite",t).objectStore(t).put(n),i=this;return new Promise((s,o)=>{e.onsuccess=(()=>{i.notifyPut(n,t);s(n)});e.onerror=(n=>{o(n)})})}getEntity(n,t,e){const i=this.transaction("readonly",e).objectStore(e).get(n);return new Promise((n,e)=>{i.onsuccess=(()=>{n(DBManager.mapEntity(t,i.result))});i.onerror=(n=>{e(n)})})}deleteEntity(n,t){const e=this.transaction("readwrite",t).objectStore(t).delete(n),i=this;return new Promise((s,o)=>{e.onsuccess=(()=>{i.notifyDelete(n,t);s(e.result)});e.onerror=(n=>{o(n)})})}notifyDelete(n,t){this.subscriptionManagerMap.contains(t)&&this.subscriptionManagerMap.get(t).notifyDelete(n)}notifyPut(n,t){this.subscriptionManagerMap.contains(t)&&this.subscriptionManagerMap.get(t).notifyPut(n)}subscribePut(n,t){this.subscriptionManagerMap.contains(n)||this.subscriptionManagerMap.set(n,new SubscriptionManager),this.subscriptionManagerMap.get(n).subscribe(t)}subscribe(n,t,e){this.subscriptionManagerMap.contains(e)||this.subscriptionManagerMap.set(e,new SubscriptionManager),this.subscriptionManagerMap.get(e).subscribe(n,t)}}export{DBConfigurer,DBManager,IndexConfig,StoreConfig,SubscriptionManager};
